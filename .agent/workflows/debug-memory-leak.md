---
description: セグメンテーションフォールとが起きる時に確認するべきこと
---

セグメンテーションフォールとが起きる時は次の点を確認してください。

1. 新しく追加した機能がマッピングされているか
2. 新しく追加したコードが、メモリ管理戦略(@docs/MEMORY_MANAGEMENT_STRATEGY.md) に反していないか
3. **ABI不整合 (Compiler vs Runtime)**:
   - **症状**: 外部関数呼び出し時 (`tl_tensor_embedding` など) に即座にクラッシュする。
   - **原因**: コンパイラの最適化（例: 小さな配列 `[1, 15043]` を `ScalarArray` として扱う）とランタイムの期待（`OpaqueTensor*` 構造体ポインタ）が食い違っている。
          **ScalarArray** は廃止された。
   - **対策**: `codegen/expr.rs` 等で、外部関数に渡すオブジェクトが必ず期待される型（`OpaqueTensor`）として生成されているか確認する。最適化を無効化するか、明示的な変換を行う。
4. **JITマッピングの欠如**:
   - **症状**: コンパイルは通るが、実行時にクラッシュする（特定の関数呼び出しで）。
   - **原因**: `codegen/builtins.rs` などで `add_global_mapping` が行われていない関数を呼び出している。
   - **対策**: 新しいランタイム関数を追加した際は、必ず JIT エンジンへのマッピングを追加する。
5. **制御フロー (`if`/`block`) における Use-After-Free (UAF)**:
   - **症状**: 実行中（特にTensorを生成するループ内）に `zsh: killed` やクラッシュが発生する。
   - **原因**: `Expr::IfExpr` や `Expr::Block` が、戻り値となる一時的な値を返す *前* に `exit_scope` で解放してしまっている。
   - **対策**: コンパイラのコード生成において、`exit_scope` を呼ぶ *前* に、戻り値に対して `tl_mem_unregister` を呼び出すようにする。