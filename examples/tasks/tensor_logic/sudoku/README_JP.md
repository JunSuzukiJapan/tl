# 微分可能 数独ソルバー

この例では、微分可能プログラミングと勾配降下法を使用して数独パズルを解く方法を示します。これは N-Queens ソルバーのアプローチと同様です。

## 問題設定
一部のセルが事前に埋められた 9×9 の数独パズルにおいて、以下の条件を満たす解を見つけます：
- 各行に 1-9 の数字がちょうど1回ずつ現れる
- 各列に 1-9 の数字がちょうど1回ずつ現れる
- 各 3×3 のボックスに 1-9 の数字がちょうど1回ずつ現れる

## 手法
1. **盤面表現**: 盤面は 9×9×9 のテンソル（学習可能なロジット：各セルに対して9つの数字の可能性を表すワンホットエンコーディング）として表現されます。
2. **ソフト制約 (Softmax)**: 数字の次元に沿って softmax を適用し、確率分布を得ます。
3. **損失関数**:
   - **行の損失**: 任意の行の数字の確率の和が 1 にならない場合にペナルティ
   - **列の損失**: 任意の列の数字の確率の和が 1 にならない場合にペナルティ
   - **セルの損失**: セルの確率が単一の数字を表していない場合にペナルティ
4. **最適化**: 勾配降下法により総損失を最小化します。

## コマンドラインでの使用方法

パズルはコマンドライン引数（81文字の文字列、空のセルは 0）として渡します：

```bash
cargo run --release -- examples/tasks/tensor_logic/sudoku/sudoku.tl -- "530070000600195000098000060800060003400803001700020006060000280000419005000080079"
```

引数が提供されない場合は、デフォルトのパズルが使用されます。

## コードのポイント

- **コマンドライン引数**: `args_count()` および `args_get(index)` 関数を使用
- **Tensor Comprehensions**: 制約式のために softmax と sum 操作を使用
- **自動微分**: `.backward()` を介して勾配を自動的に計算

## 注意

これは微分可能な制約充足のデモンストレーションです。現在の実装では、難易度の高いパズルで収束させるためにパラメータの調整が必要な場合があります。
